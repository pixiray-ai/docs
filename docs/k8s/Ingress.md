# SignalR Ingress in Azure Kubernetes Services aka AKS

# TL;DR

# Executive Summary

# Prerequisites
- Basic Understanding of [Kubernetes]() and [Ingress]()
- Azure Subscription
- Basic understanding of Azure (recommended)

# Content

# Chapter 1 - So the server is in command? Or the client? Sorry - you lost me!? What Signalr-R really is.

## Introduction

In today's digital landscape, real-time communication has become increasingly crucial for developers. Whether you're building a chat application, collaborative editing tool, or a live dashboard, the ability to instantly exchange information between clients and servers is paramount. This is where SignalR comes into play. In this blog post, we will explore the fundamentals of SignalR and how it empowers developers to create interactive and responsive applications.

## What is SignalR?

SignalR is an open-source real-time web application framework developed by Microsoft. It simplifies the process of adding real-time functionality to applications by providing an abstraction layer over various communication technologies. With SignalR, developers can build applications that enable instant bi-directional communication between clients (such as web browsers, apps, ...) and servers.

## Key Features and Benefits:

1. Real-Time Communication: SignalR facilitates real-time communication by establishing persistent connections between clients and servers. This enables instant data transmission, eliminating the need for clients to manually refresh the page or continuously poll the server for updates.

2. Broad Client Support: SignalR supports a wide range of client platforms, including web browsers (JavaScript), mobile devices (iOS, Android), desktop applications (Windows, macOS), and even IoT devices. This versatility allows developers to create interactive experiences across multiple platforms with ease.

3. Scalability: SignalR is designed to scale effortlessly. It supports various hosting options, such as self-hosting within your application or using Microsoft Azure's cloud infrastructure. SignalR automatically manages connections, load balancing, and server affinity, ensuring seamless performance even with a large number of clients.

4. Built-in Connection Management: SignalR abstracts away the complexities of connection management, including negotiation, reconnection, and error handling. It handles connectivity issues transparently, enabling automatic reconnection in case of network disruptions and other failure scenarios.

5. Flexible Communication Patterns: SignalR supports multiple communication patterns, including one-to-one, one-to-many, and broadcasting. This flexibility allows developers to tailor their applications to specific use cases, such as private messaging, real-time notifications, or collaborative editing.

## How SignalR Works:
SignalR leverages various underlying transport technologies to establish real-time connections. It uses WebSockets as the primary transport protocol, which provides a full-duplex communication channel over a single TCP connection, enabling efficient real-time data transfer. However, if WebSockets are not supported by the client or server, SignalR gracefully falls back to alternative transport mechanisms, such as Server-Sent Events (SSE) or Long Polling.

SignalR employs a hub-based architecture, where developers define server-side hub classes responsible for handling incoming client requests and broadcasting messages to connected clients. Clients can invoke server-side methods through hub proxies, which are automatically generated by SignalR. This two-way communication model ensures a smooth and seamless experience for developers when building real-time applications.

TODO: Explain necessary basics ...

## Conclusion:
SignalR empowers developers to create highly interactive and responsive applications by providing a simple yet powerful framework for real-time communication. Its broad client support, scalability, and built-in connection management make it a popular choice for a wide range of applications. By leveraging SignalR, developers can focus on delivering engaging user experiences while leaving the complexities of real-time communication to the framework. So, whether you're building a collaborative application or enhancing the responsiveness of an existing project, SignalR is a valuable tool in your development arsenal.

## Summarization by Microsoft AspNet Core Team

- Framework for duplex RPC & streaming between client and server
- Provides "real-time" messaging & server-push functionality  l
- Protocols for transport and messaging layers allow broad reach
- Server support for client addressing & grouping, e.g.:
    - Send to all clients
    - Send to this one client (connection or user)
    - Send to this group of clients

Supporting multiple clients
- SignalR supports different client types
- HTTP transport
    - [WebSockets](https://websockets.spec.whatwg.org/)
    - ServerSentEvents
    - [Long Polling (IETF RFC:6202)](https://datatracker.ietf.org/doc/html/rfc6202#section-2.1)
- SignalR Client SDKs
    - [JavaScript](https://learn.microsoft.com/en-us/aspnet/core/signalr/javascript-client?view=aspnetcore-7.0&tabs=visual-studio)
    - [.NET](https://learn.microsoft.com/en-us/aspnet/core/signalr/dotnet-client?view=aspnetcore-7.0&tabs=visual-studio)
    - [Java](https://learn.microsoft.com/en-us/aspnet/core/signalr/java-client?view=aspnetcore-7.0)
    - [Swift]()
    - Python
    - C++

More on Signal-R

This client flexibility is basically enabled by two protocol layers.
- [Transport protocol](https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md) provides flexibility for connection types, e.G. HTTP vs TCP/IP
- [Hub protocol](https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/HubProtocol.md) provides flexibility for message formats, e.g. JSON vs. MessagePack

Source:
- [David Fowler]() and [Demian Edwards]() at [NDC London January 2020 - SignalR Deep Dive: Building Servers - David Fowler & Damian Edwards](https://www.youtube.com/watch?v=iL9nLAjCPtM)
- [David Fowler]() and [Demian Edwards]() at [ Build 2018 - Meet the new stack for real-time web communication: ASP.NET Core SignalR](https://www.youtube.com/watch?v=Lws0zOaseIM)

Changes in SignalR with aspnet core to previous Implementation
- No more jQuery dependency
- No more auto-reconnect with message replay
- No more hub state
- No more multi-hub endpoints
- No more single-model scale-out
- No more multi server ping-pong (nor requires sticky sessions)

## Pre-Requisites

This sample and tutorial expects that you have a kubernetes cluster in microsoft azure that supports Azure CNI.
- You have installed the latest version of Azure CNI.
- You have installed kubectl
- Your desired Ingress, Kubernetes Cluster and Helm are compatible. 

Make sure you have a public LB your DNS can point to. 

Install a LB for incomming traffic. There are two ways how you can achieve this. The simplest way to allocate a static Public Ip.

We want to find the resource group that holds the virtual machine agent-pool for your aks cluster.
you can use the following command in azure cli

```console
az group list
```
Now we want to create the public static ip for loadbalancing to the cluster.

```console
az network public-ip create --resource-group YOURAGENTPOOLRG --name YOURDESIREDIPNAME --sku Standard --allocation-method static --query publicIp.ipAddress -o tsv
```

OPTIONAL

if you are using DNS Zone in Azure you can now point to this IP address.

```console
az network dns record-set a add-record --resource-group YOURRGNAME --zone-name YOURDOMAIN.COM --record-set-name YOURDESIREDCNAME --ipv4-address 000.000.000.000
```
Make sure to use IP from previous call.

# Ingress Overview

## Scope


## Desired Ingress

Implementation:

### Service bind to IP

1. Create Namespace in AKS Cluster

2. Create a pod running

3. Bind the pod to a LB

DONE

### Implementation with NGINX INGRESS

1. Create a Namespace in AKS Cluser

get namespaces in the cluster

```console
kubectl get namespace
```

create a new namespace 

```console
kubectl create namespace YOUR_NAMESPACE
```

get namespaces in the cluster

```console
kubectl get namespace
```

Make sure you have removed any previous installations of NGINX see this guide: TODO

2. Install NGINX Ingress Controller with the following - configuration

TODO: Double check

Make sure to replace with IP from step 1. 
And set the Namespace to YOUR_NAMESPACE you just created in kubernetes.

```console
helm install ingress-nginx ingress-nginx/ingress-nginx \
    --namespace YOUR_NAMESPACE \ 
    --set controller.replicaCount=2 \
    --set controller.nodeSelector."beta\.kubernetes\.io/os"=linux \
    --set defaultBackend.nodeSelector."beta\.kubernetes\.io/os"=linux \
    --set controller.service.externalTrafficPolicy=Local \
    --set controller.service.loadBalancerIP="000.000.000.000" 
```

TODO Helm Install check ???

TODO Ingress check ???

3. Create Secrets for TLS

TODO: ??? Need ivis history

4. Deploy pods

The YAML for the POD

```yaml
  GNU nano 6.2                                                           chat-app.yaml                                                                     apiVersion: apps/v1
kind: Deployment
metadata:
  name: chat
  labels:
    app: signalrchat
    group: testing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: signalrchat
  template:
    metadata:
      labels:
        app: signalrchat
        group: testing
    spec:
      containers:
        - name: signalrchat
          image: pixiray.azurecr.io/signalrchat
          imagePullPolicy: Always
          ports:
            - name: web
              containerPort: 8080
            - name: websocket
              containerPort: 5000
          env:
          - name: "CORS_ORIGINS"
            value: "https://demo.pixiray.ninja;http://demo.pixiray.ninja"
         # - name: "KNOWN_PROXIES"
         #   value: "10.0.185.130"
```

- You will need both http/s domains listed. Please note this is due to the handshake of Signal-r client.
- please note the application will run without explicit proxy configuration

```console
kubectl apply -f chat-app.yaml -n YOUR_NAMESPACE
```

Make sure the deployment went well

```console
kubectl get pods -n YOUR_NAMESPACE
```

Select the pod that has been created and copy the name

```console
kubectl describe pod PASTE_POD_NAME_HERE -n YOUR_NAMESPACE
```

You can access the logs of the pod and therefor the signalr app at any time by using 

OPTIONAL AT THIS POINT

```console
kubectl logs PASTE_POD_NAME_HERE -n YOUR_NAMESPACE
```

5. Deploy the service 

```yaml
  # Default values for azure-vote-front.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
kind: Service
apiVersion: v1
metadata:
  name:  signalrchat-service
spec:
  selector:
    app:  signalrchat
  ports:
  - name:  web
    port:  8080
    targetPort:  80
  - name:  websocket
    port:  5000
    targetPort: 5000
  sessionAffinity: ClientIP
  type: ClusterIP
```
Check the service by using 

```console
kubectl get svc -n YOUR_NAMESPACE
```

6. Deploy INGRESS
```yaml
  GNU nano 6.2                                                            ingress.yaml                                                                     apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: test-ingress
  namespace: wolf
  annotations:
    nginx.ingress.kubernetes.io/use-regex: "true"
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, PATCH, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-headers: "Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-SignalR-User-Agent"
    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/affinity-mode: persistent
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
spec:
  tls:
    - hosts:
      - "yourdomain.com"
      secretName: changetoyoursecretvariable
  ingressClassName: nginx
  rules:
  - host: "subdomain.yourdomain.com"
    http:
      paths:
        - pathType: Prefix
          path: "/"
          backend:
            service:
              name: hello-service
              port:
                number: 80
          path: "/chat"
          backend:
            service:
              name: signalrchat-service
              port:
                number: 80
```

```console
kubectl apply -f ingress.yaml -n YOUR_NAMESPACE
```

Check the just generated Ingress

```console
kubectl describe ing -n YOUR_NAMESPACE
```

Now let us chat. About the YAML and the NGINX Configuration and why this would work.
TBD

Call the site via curl or browser.

Check the logs?

if err check the ingress logs

```console
kubectl get svc -n YOUR_NAMESPACE
```
copy the nginx service behind logs

```console
kubectl logs ingress-nginx-controller-55d445d69d-flxmb -n YOUR_NAMESPACE
```

```console
kubectl logs PASTE_POD_NAME_HERE -n YOUR_NAMESPACE
```

The desired output on logs of the pod should be:
```log
[19:49:04 INF] Starting web host
[19:49:04 INF] KNOWN_PROXIES: null
[19:49:04 INF] CORS_ORIGINS: ["https://demo.invite-apollo.app", "http://demo.invite-apollo.app"]
[19:49:04 WRN] Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed.
[19:49:04 INF] User profile is available. Using '/root/.aspnet/DataProtection-Keys' as key repository; keys will not be encrypted at rest.
[19:49:04 INF] Creating key {b00c87ea-9054-4360-a204-46d726de91f7} with creation date 2023-06-10 19:49:04Z, activation date 2023-06-10 19:49:04Z, and expiration date 2023-09-08 19:49:04Z.
[19:49:04 WRN] No XML encryptor configured. Key {b00c87ea-9054-4360-a204-46d726de91f7} may be persisted to storage in unencrypted form.
[19:49:04 INF] Writing data to file '/root/.aspnet/DataProtection-Keys/key-b00c87ea-9054-4360-a204-46d726de91f7.xml'.
[19:49:05 INF] Now listening on: http://[::]:80
[19:49:05 INF] Application started. Press Ctrl+C to shut down.
[19:49:05 INF] Hosting environment: Production
[19:49:05 INF] Content root path: /app
[19:49:07 INF] Request starting HTTP/1.1 POST http://demo.invite-apollo.app/chathub/negotiate?negotiateVersion=1 text/plain;charset=UTF-8 0
[19:49:07 WRN] Failed to determine the https port for redirect.
[19:49:07 INF] CORS policy execution successful.
[19:49:07 INF] Executing endpoint '/chatHub/negotiate'
[19:49:07 INF] Executed endpoint '/chatHub/negotiate'
[19:49:07 INF] Request finished HTTP/1.1 POST http://demo.invite-apollo.app/chathub/negotiate?negotiateVersion=1 text/plain;charset=UTF-8 0 - 200 316 application/json 54.4617ms
[19:49:07 INF] Request starting HTTP/1.1 GET http://demo.invite-apollo.app/chathub?id=qe1W8vD1zC4RG97WMYpwKg - -
[19:49:07 INF] CORS policy execution successful.
[19:49:07 INF] Executing endpoint '/chatHub'
[19:49:07 INF] Client connected: yzOuB7O2q8x1rCiDZoA18Q
[19:49:07 INF] Request starting HTTP/1.1 POST http://demo.invite-apollo.app/chathub/negotiate?negotiateVersion=1 text/plain;charset=UTF-8 0
[19:49:07 INF] CORS policy execution successful.
[19:49:07 INF] Executing endpoint '/chatHub/negotiate'
[19:49:07 INF] Executed endpoint '/chatHub/negotiate'
[19:49:07 INF] Request finished HTTP/1.1 POST http://demo.invite-apollo.app/chathub/negotiate?negotiateVersion=1 text/plain;charset=UTF-8 0 - 200 316 application/json 1.7565ms
[19:49:07 INF] Request starting HTTP/1.1 GET http://demo.invite-apollo.app/chathub?id=MdL8KnBVL1XgyvhsgEZOCw - -
[19:49:07 INF] CORS policy execution successful.
[19:49:07 INF] Executing endpoint '/chatHub'
[19:49:07 INF] Client connected: UH7Eqz3_wr2TER-7Y1IYog
[19:49:09 INF] Received message from Patric: Hello World
[19:49:09 INF] Received message from Patric: Hello World
[19:49:09 INF] Received message from Patric: Hello World
[19:49:10 INF] Received message from Patric: Hello World
[19:49:10 INF] Received message from Patric: Hello World
[19:49:10 INF] Received message from Patric: Hello World
[19:49:10 INF] Received message from Patric: Hello World
[19:49:10 INF] Received message from Patric: Hello World
[19:50:21 INF] Received message from Patric: Hello World
[19:50:21 INF] Received message from Patric: Hello World
[19:50:21 INF] Received message from Patric: Hello World
[19:50:21 INF] Received message from Patric: Hello World
[19:50:21 INF] Received message from Patric: Hello World
[19:50:49 INF] Received message from Patric: Hello World
[19:51:10 INF] Request starting HTTP/1.1 GET http://demo.invite-apollo.app/ - -
[19:51:10 INF] Executing endpoint '/Index'
[19:51:10 INF] Route matched with {page = "/Index"}. Executing page /Index
[19:51:10 INF] Executing handler method Signalrchat.Pages.IndexModel.OnGet - ModelState is Valid
[19:51:10 INF] Executed handler method OnGet, returned result .
[19:51:10 INF] Executing an implicit handler method - ModelState is Valid
[19:51:10 INF] Executed an implicit handler method, returned result Microsoft.AspNetCore.Mvc.RazorPages.PageResult.
[19:51:10 INF] Executed page /Index in 73.2256ms
[19:51:10 INF] Executed endpoint '/Index'
[19:51:10 INF] Request finished HTTP/1.1 GET http://demo.invite-apollo.app/ - - - 200 - text/html;+charset=utf-8 92.6752ms
[19:51:10 INF] Executed endpoint '/chatHub'
[19:51:10 INF] Request finished HTTP/1.1 GET http://demo.invite-apollo.app/chathub?id=qe1W8vD1zC4RG97WMYpwKg - - - 101 - - 123175.9985ms
[19:51:10 INF] Request starting HTTP/1.1 POST http://demo.invite-apollo.app/chathub/negotiate?negotiateVersion=1 text/plain;charset=UTF-8 0
[19:51:10 INF] CORS policy execution successful.
[19:51:10 INF] Executing endpoint '/chatHub/negotiate'
[19:51:10 INF] Executed endpoint '/chatHub/negotiate'
[19:51:10 INF] Request finished HTTP/1.1 POST http://demo.invite-apollo.app/chathub/negotiate?negotiateVersion=1 text/plain;charset=UTF-8 0 - 200 316 application/json 0.8206ms
[19:51:11 INF] Request starting HTTP/1.1 GET http://demo.invite-apollo.app/chathub?id=tCD5yROJOi9tupkpFWqo0w - -
[19:51:11 INF] CORS policy execution successful.
[19:51:11 INF] Executing endpoint '/chatHub'
[19:51:11 INF] Client connected: v-XnI0nJjWrRZbxL3ZXxnQ
[19:51:17 INF] Received message from hallo: Test
[19:51:19 INF] Received message from hallo: Test
[19:51:19 INF] Received message from hallo: Test
[19:51:19 INF] Received message from hallo: Test
[19:51:20 INF] Received message from hallo: Test
[19:51:20 INF] Received message from hallo: Test
[19:51:20 INF] Received message from hallo: Test
[19:52:15 INF] Received message from hallo: Test
[19:52:16 INF] Received message from hallo: Test
[19:52:16 INF] Received message from hallo: Test
[19:52:16 INF] Received message from hallo: Test
```
And the corresponding client logs from the f12 debugger
TBD Screenshot


Helpfull commands:

Find a helm install

```console
helm ls -A
```
```console
kubectl get all --all-namespaces -l='app.kubernetes.io/managed-by=Helm'
```







